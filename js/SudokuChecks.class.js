// Generated by CoffeeScript 1.6.3
(function() {
  this.SudokuChecks = (function() {
    function SudokuChecks() {}

    SudokuChecks.unique = function(board, r, c) {
      var cb, i, j, rb, set, _i, _j, _k, _ref, _ref1, _ref2;
      set = ~board.cellAt(r, c).getMask();
      for (i = _i = 0, _ref = board.dim2; _i < _ref; i = _i += 1) {
        if (i !== c) {
          board.cellAt(r, i).setMask(board.cellAt(r, i).getMask() & set);
        }
        if (i !== r) {
          board.cellAt(i, c).setMask(board.cellAt(i, c).getMask() & set);
        }
        if (board.checkDiags) {
          if (r === c && i !== r) {
            board.cellAt(i, i).setMask(board.cellAt(i, i).getMask() & set);
          }
          if (r === board.dim2 - c - 1 && i !== r) {
            board.cellAt(i, board.dim2 - i - 1).setMask(board.cellAt(i, board.dim2 - i - 1).getMask() & set);
          }
        }
      }
      rb = Math.floor(r / board.dim) * board.dim;
      cb = Math.floor(c / board.dim) * board.dim;
      for (i = _j = rb, _ref1 = rb + board.dim; _j < _ref1; i = _j += 1) {
        for (j = _k = cb, _ref2 = cb + board.dim; _k < _ref2; j = _k += 1) {
          if (i !== r || j !== c) {
            board.cellAt(i, j).setMask(board.cellAt(i, j).getMask() & set);
          }
        }
      }
      return true;
    };

    SudokuChecks.onePlace = function(cells) {
      var i, k, n, p, x, _i, _ref;
      if (!cells[0]) {
        return;
      }
      for (i = _i = 0, _ref = cells[0].boardObj.dim2; _i < _ref; i = _i += 1) {
        n = 0;
        p = 1 << i;
        x = -1;
        for (k in cells) {
          if (cells[k].getValue() === '.' && (p & cells[k].getMask())) {
            n++;
            x = k;
          }
        }
        if (n === 1) {
          cells[x].setMask(p);
          cells[x].setValue(cells[0].boardObj.set.charAt(Math.log(p) / Math.log(2)));
        }
      }
      return true;
    };

    SudokuChecks.oneUnknown = function(cells) {
      var c, val, valid;
      for (c in cells) {
        if (cells[c].getValue() === '.' && cells[c].getUnknownsCount() === 1) {
          valid = cells[c].getMask();
          val = cells[c].boardObj.set.charAt(Math.log(valid) / Math.log(2));
          cells[c].setValue(val);
        }
      }
      return true;
    };

    SudokuChecks.twoValPlaces = function(cells) {
      var curMask, dim2, i, j, k, n, newMask, p, _i, _j, _ref, _ref1;
      if (!cells[0]) {
        return;
      }
      dim2 = cells[0].boardObj.dim2;
      console.group('twoValPlaces: (%o) %o', dim2, cells);
      for (i = _i = 0, _ref = dim2 - 1; _i < _ref; i = _i += 1) {
        for (j = _j = _ref1 = i + 1; _j < dim2; j = _j += 1) {
          n = 0;
          p = (1 << i) | (1 << j);
          console.log('Now checking (%o, %o) mask: %o', i + 1, j + 1, p);
          for (k in cells) {
            if (cells[k].getValue() === '.' && (cells[k].getMask() & p) === p) {
              n++;
              console.log('%d: %d, %d (%o, %o)', n, p, cells[k].getMask(), p & cells[k].getMask(), (p & cells[k].getMask()) === p);
            }
          }
          if (n > 0) {
            console.info('Have %d matches.', n);
          }
          if (n === 2) {
            console.warn('Two matches!');
            for (k in cells) {
              if (cells[k].getValue() === '.' && (cells[k].getMask() & p) === p) {
                cells[k].setMask(p);
              } else if (cells[k].getValue() === '.') {
                curMask = cells[k].getMask();
                console.log('Current Mask: %o', curMask);
                newMask = curMask & ~p;
                console.log('New Mask: %o', newMask);
                cells[k].setMask(newMask);
              }
            }
          }
        }
      }
      console.groupEnd();
      return true;
    };

    return SudokuChecks;

  })();

}).call(this);
